<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dé 3D qui tourne (HTML/CSS/JS)</title>
  <style>
    :root {
      --size: 140px;              /* Taille du dé */
      --face: #ffffff;            /* Couleur des faces */
      --edge: #d9d9d9;            /* Bord des faces */
      --pip: #111111;             /* Couleur des points */
      --bg-1: #0f172a;            /* Décor (si besoin) */
      --bg-2: #1f2937;            /* Décor (si besoin) */
      --accent: #60a5fa;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: #e5e7eb;
      background: transparent; /* overlay compatible */
      display: grid;
      place-items: center;
    }

    /* Conteneur d'apparition/disparition */
    #root {
      opacity: 0;
      transform: scale(0.98);
      transition: opacity .35s ease, transform .35s ease;
      will-change: opacity, transform;
      display: grid;
      gap: 16px;
      justify-items: center;
    }
    #root.show { opacity: 1; transform: scale(1); }
    #root.hide { opacity: 0; transform: scale(0.98); }

    /* Zone 3D */
    .scene {
      width: var(--size);
      height: var(--size);
      perspective: 900px;
      perspective-origin: 50% 40%;
      position: relative;
    }


    /* Le cube */
    .cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      will-change: transform;
      transition: transform 1.2s cubic-bezier(0.2, 0.7, 0.2, 1);
    }

    /* Face du dé */
    .face {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      align-items: center;
      justify-items: center;
      background: radial-gradient(120% 100% at 30% 25%, #fff, #f2f2f2 60%, #ececec 100%);
      background-color: var(--face);
      border: 1px solid var(--edge);
      border-radius: 14px;
    }

    .pip {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: radial-gradient(12px 12px at 35% 35%, #333, var(--pip));
      box-shadow: 0 1px 0 rgba(255,255,255,0.6) inset, 0 2px 4px rgba(0,0,0,0.35);
    }

    /* Positionnement des faces autour du cube */
    .front  { transform: translateZ(calc(var(--size) / 2)); }
    .back   { transform: rotateY(180deg) translateZ(calc(var(--size) / 2)); }
    .right  { transform: rotateY( 90deg) translateZ(calc(var(--size) / 2)); }
    .left   { transform: rotateY(-90deg) translateZ(calc(var(--size) / 2)); }
    .top    { transform: rotateX( 90deg) translateZ(calc(var(--size) / 2)); }
    .bottom { transform: rotateX(-90deg) translateZ(calc(var(--size) / 2)); }

    /* Pips position helpers (grid area) */
    .r1 { grid-row: 1; }
    .r2 { grid-row: 2; }
    .r3 { grid-row: 3; }
    .c1 { grid-column: 1; }
    .c2 { grid-column: 2; }
    .c3 { grid-column: 3; }

    /* Effet pendant le roll */
    .rolling + .shadow { transform: scale(0.85) translateY(2px); }

    @media (prefers-reduced-motion: reduce) {
      .cube { transition-duration: 0.01ms; }
      #root { transition-duration: 0.01ms; }
    }
  </style>
</head>
<body>
  <div id="root" aria-live="polite">
    <div class="scene">
      <div class="cube" id="cube" aria-label="Dé 3D"></div>
      <div class="shadow"></div>
    </div>
  </div>

  <script>
    // --- Construction des faces avec les pips (3x3) ---
    const cubeEl = document.getElementById('cube');
    const rootEl = document.getElementById('root');

    function makeFace(className, pipPositions) {
      const face = document.createElement('div');
      face.className = `face ${className}`;
      pipPositions.forEach(([r, c]) => {
        const pip = document.createElement('div');
        pip.className = `pip r${r} c${c}`;
        face.appendChild(pip);
      });
      return face;
    }

    const PIPS = {
      1: [[2,2]],
      2: [[1,1],[3,3]],
      3: [[1,1],[2,2],[3,3]],
      4: [[1,1],[1,3],[3,1],[3,3]],
      5: [[1,1],[1,3],[2,2],[3,1],[3,3]],
      6: [[1,1],[1,3],[2,1],[2,3],[3,1],[3,3]]
    };

    // front=1, back=6, right=3, left=4, top=5, bottom=2
    cubeEl.append(
      makeFace('front',  PIPS[1]),
      makeFace('back',   PIPS[6]),
      makeFace('right',  PIPS[3]),
      makeFace('left',   PIPS[4]),
      makeFace('top',    PIPS[5]),
      makeFace('bottom', PIPS[2])
    );

    const FACE_TO_ANGLES = {
      1: { x:   0, y:   0 },
      2: { x:  90, y:   0 },
      3: { x:   0, y: -90 },
      4: { x:   0, y:  90 },
      5: { x: -90, y:   0 },
      6: { x:   0, y: 180 }
    };

    let isRolling = false;
    let hideTimeout = null;
    let lastTransform = { x: 0, y: 0, z: 0 };

    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function currentCSSTransformToAngles() {
      const m = cubeEl.style.transform.match(/rotateX\(([-\d.]+)deg\)\s*rotateY\(([-\d.]+)deg\)\s*rotateZ\(([-\d.]+)deg\)/);
      if (m) return { x: parseFloat(m[1]), y: parseFloat(m[2]), z: parseFloat(m[3]) };
      return { ...lastTransform };
    }

    function setTransform(x, y, z, durationMs = null, timing = null) {
      if (durationMs != null) cubeEl.style.transitionDuration = `${durationMs}ms`;
      if (timing != null) cubeEl.style.transitionTimingFunction = timing;
      const t = `rotateX(${x}deg) rotateY(${y}deg) rotateZ(${z}deg)`;
      cubeEl.style.transform = t;
      lastTransform = { x, y, z };
    }

    function fadeIn() {
      rootEl.classList.remove('hide');
      void rootEl.offsetWidth; // reflow
      rootEl.classList.add('show');
    }
    function fadeOut() {
      rootEl.classList.remove('show');
      rootEl.classList.add('hide');
    }

    function rollDie() {
      if (isRolling) return;
      isRolling = true;
      cubeEl.classList.add('rolling');
      clearTimeout(hideTimeout);

      // Affiche le conteneur
      fadeIn();

      // PHASE 1 — pré-spin très rapide (linear)
      const preSpins = {
        x: randInt(3, 6) * 360,
        y: randInt(3, 6) * 360,
        z: randInt(1, 4) * 360,
        dur: 250
      };
      const c1 = currentCSSTransformToAngles();
      setTransform(c1.x + preSpins.x, c1.y + preSpins.y, c1.z + preSpins.z, preSpins.dur, 'linear');

      const onPreEnd = (ev) => {
        if (ev.propertyName !== 'transform') return;
        cubeEl.removeEventListener('transitionend', onPreEnd);

        // PHASE 2 — spin vers la face cible avec easing (ralentissement)
        const face = randInt(1, 6);
        const target = FACE_TO_ANGLES[face];
        const xSpins = randInt(2, 5) * 360;
        const ySpins = randInt(2, 6) * 360;
        const zSpins = randInt(0, 4) * 360;
        const duration = randInt(900, 1500);

        cubeEl.style.transitionTimingFunction = 'cubic-bezier(0.2, 0.7, 0.2, 1)';
        const { x: cx, y: cy, z: cz } = currentCSSTransformToAngles();
        const nx = cx + xSpins + target.x;
        const ny = cy + ySpins + target.y;
        const nz = cz + zSpins;
        setTransform(nx, ny, nz, duration);

        const onFinalEnd = (ev2) => {
          if (ev2.propertyName !== 'transform') return;
          cubeEl.removeEventListener('transitionend', onFinalEnd);
          isRolling = false;
          cubeEl.classList.remove('rolling');
          // Notifie la face sortie
          cubeEl.dispatchEvent(new CustomEvent('roll-end', { detail: { face, angles: { x: nx, y: ny, z: nz } } }));

          // Reste affiché 5s puis fade out
          hideTimeout = setTimeout(() => {
            fadeOut();
          }, 5000);
        };
        cubeEl.addEventListener('transitionend', onFinalEnd);
      };
      cubeEl.addEventListener('transitionend', onPreEnd);
    }

    // Expose pour déclenchement externe (Streamer.bot)
    window.rollDie = rollDie;
    window.rollTo = function(face) {
      if (!FACE_TO_ANGLES[face] || isRolling) return;
      fadeIn();
      const target = FACE_TO_ANGLES[face];
      const { x: cx, y: cy, z: cz } = currentCSSTransformToAngles();
      const nx = cx + target.x;
      const ny = cy + target.y;
      const nz = cz;
      setTransform(nx, ny, nz, 600, 'cubic-bezier(0.2, 0.7, 0.2, 1)');
      clearTimeout(hideTimeout);
      hideTimeout = setTimeout(() => fadeOut(), 5000);
    };

    // Au chargement: orientation propre, fade-in + roll automatique (à chaque refresh)
    function init() {
      setTransform(0, 0, 0, 1);
      requestAnimationFrame(() => { rollDie(); });
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
